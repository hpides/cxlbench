# Based on PerMA-Bench config:
# https://github.com/hpides/perma-bench/blob/7c8cc3a5cc0062475586fb95a9577fe8cdc9cd71/workloads/operations/hybrid_tree_index.yaml#L1-L40

# Represent a hybrid tree-index structure split into index lookups and updates.

# The tree-index structure is inspired by FPTree (Oukid et al., SIGMOD, 2016).
# As in the original paper, we assume 1024 Byte leaf nodes, which hold 64 records and 2048 Byte inner nodes, which
# hold 128 records. A tree with 1 billion entries has a height of 6 (128^4 inner nodes * 64 keys per leaf node > 1
# billion) including the root. We assume the root, first and second level to be in the L3 cache
# (128^2 * 2 KiB = ~33MB). To find a record, we need 2 random node lookup in DRAM and 1 dependent random lookup in PMem.
# For 1024/512 Byte inner/leaf nodes, we assume 7 levels, where root + 2 levels fit into cache (~4 MB).
# For 512/256 Byte inner/leaf nodes, we assume 8 levels, where root + 3 levels fit into cache (~16 MB).
tree_index_lookup:
  matrix:
    number_threads: [ 1, 4, 8, 12, 16 ]
    # m0, dram in perma
    numa_memory_nodes: [[ 0,1,2,3 ], [ 4,5,6,7 ], [ 8 ]]
    # m1, pmem in perma
    secondary_numa_memory_nodes: [[ 0,1,2,3 ], [ 4,5,6,7 ], [ 8 ]]
    custom_operations:
      # PMem original:
      # - "rd_2048,rd_2048,rp_1024"
      # - "rd_1024,rd_1024,rd_1024,rp_512"
      # - "rd_512,rd_512,rd_512,rp_256"
      # Modified, replaced d with m0, p with m1
      - "m0_r_2048,m0_r_2048,m1_r_1024"
      # - "m0_r_1024,m0_r_1024,m0_r_1024,m1_r_512"
      # - "m0_r_512,m0_r_512,m0_r_512,m1_r_256"

  args:
    # m0, dram in perma
    memory_region_size: 4G
    # m1, pmem in perma
    secondary_memory_region_size: 7G

    numa_task_nodes: [ 0 ]
    number_operations: 100000000
    exec_mode: custom

# To write an entry, FPTree performs 3 flushes, one for the data, one for the fingerprint, and one for the slot index.
# The data is randomly positioned in the node and the other two flushes are at the head.
# An insertion is a lookup, followed by the record entry. We use the same sizes as above.
tree_index_update:
  matrix:
    number_threads: [ 1, 4, 8, 12, 16 ]
    # m0, dram in perma
    numa_memory_nodes: [[ 0,1,2,3 ], [ 4,5,6,7 ], [ 8 ]]
    # m1, pmem in perma
    secondary_numa_memory_nodes: [[ 0,1,2,3 ], [ 4,5,6,7 ], [ 8 ]]
    custom_operations:
      # PMem original:
      # - "rd_2048,rd_2048,rp_1024,wp_64_cache_512,wp_64_cache_-512,wp_64_cache"
      # - "rd_1024,rd_1024,rd_1024,rp_512,wp_64_cache_256,wp_64_cache_-256,wp_64_cache"
      # - "rd_512,rd_512,rd_512,rp_256,wp_64_cache_128,wp_64_cache_-128,wp_64_cache"
      # Modification: removed flush instructions
      - "m0_r_2048,m0_r_2048,m1_r_1024,m1_w_64_none_512,m1_w_64_none_-512,m1_w_64_none"
      # - "m0_r_1024,m0_r_1024,m0_r_1024,m1_r_512,m1_w_64_none_256,m1_w_64_none_-256,m1_w_64_none"
      # - "m0_r_512,m0_r_512,m0_r_512,m1_r_256,m1_w_64_none_128,m1_w_64_none_-128,m1_w_64_none"

  args:
    # m0, dram in perma
    memory_region_size: 4G
    # m1, pmem in perma
    secondary_memory_region_size: 7G

    numa_task_nodes: [ 0 ]
    number_operations: 100000000
    exec_mode: custom
